# AXISEM input file for python interface (PyAxi.py)
# This file should be located in the same folder as PyAxi.py

[general]
address = ..                             ; address where AXISEM is located
mesh_name = DEFAULT_MESHER               ; Name for the mesh folder
solver_name = DEFAULT_SOLVER             ; Name for the solver folder
verbose = N                              ; for debugging purposes

# IMPORTANT:
# 'new_mesh' flag controls all the required steps that you want for your simulation: 
# (except for post_processing and test)

# Y: means that you want to run the AXISEM for a new mesh! (so MESHER and SOLVER)
# N: to re-run the solver with different parameters but the same mesh (so SOLVER) ---> obviously you need an old mesh!
# M: if you change the flag to M, you have a full control on all steps (please refer to the bottom of this section!)

new_mesh = Y                             
post_processing = Y                      ; perform the post processing step

# ATTENTION: if you change the 'new_mesh' flag to 'M' [Manual] 
# you could change these flags in a way that you want
mesher = N                               ; to run the mesher
solver = N                               ; to run the solver
mesher_makefile = Y                      ; Create Mesher Makefile? (just once!)
mesher_make = Y                          ; Run make clean; make for mesher
mesher_move = Y                          ; Run movemesh.csh
solver_makefile = Y                      ; Create Solver Makefile?
solver_cp = Y                            ; defines the mesh as a header
solver_make = Y                          ; Run make clean; make for mesher

[mpi_netCDF]
make_flag = gfortran                     ; add required flags to makemake.pl
mpi_compiler = mpif90 -O3 -fbacktrace    ; mpi compiler of your local machine

netCDF = N                            
# include folder of where the libnetcdff.a is located (type locate libnetcdff.a)
netCDF_LIBS = -lm -L $(HOME)/local/lib -lnetcdff -Wl,-rpath,$(HOME)/local/lib
netCDF_INCLUDE = -I $(HOME)/local/include -I /usr/include

[mesher]
model = 'prem_light'                     ; Background model: prem,prem_solid etc
period = 50.                             ; DOMINANT period [s]
no_proc = 4                              ; Number of processors to be used
vtk_output = .false.                     ; write vtk output (may cause memory problem for high frequencies (~2s))

[solver]
no_simu = 1                              ; number of simulations. 1: single Mij/f_i; 2: forces; 4: moment tensor
seis_length = 1800.                      ; seismogram length [s]
time_step = 0.0                          ; time step [s]. Put to 0.0 to use mesher's suggestion (mesh_params.h)
time_scheme = newmark2                   ; time scheme: newmark2,symplec4,ML_SO4m5,ML_SO6m7,KL_O8m17,SS_35o10
source_type = sourceparams               ; source file type: 'sourceparams','cmtsolut'
receiver_type = stations                 ; receiver file type: 'colatlon','stations','database'
save_XDMF = .false.                      ; save XDMF files (high resolution 2D wavefields), more options in inparam_xdmf
force_aniso = .false.                    ; force anisotropic model handling
viscoelastic_attenuation = .false.       ; include viscoelastic attenuation

#-----------------------------------------------------------------------
# sourceparams parameters: (not valid for CMTSOLUTION)
sourceparams_type = 'monopole'      ; excitation type: 'monopole', 'dipole', 'quadpole'
sourceparams_MDQ = 'explosion'
# 'explosion','mxx_p_myy','mzz','vertforce' (MONOPOLE)
# 'mxz', 'myz', 'xforce', 'yforce'          (DIPOLE)
# 'mxy', 'mxx_m_myy'                        (QUADRUPOLE)

src_Mzz = 1.E20
src_Mxx = 1.E20
src_Myy = 1.E20
src_Mxz = 0.E20
src_Myz = 0.E20
src_Mxy = 0.E20

source_dp = 100.                         ; source depth [km]
source_colat = 0.0                       ; source colatitude [degrees]
source_lon = 0.0                         ; source longitude [ldegrees]
source_stf = 'dirac_0'                   ; source time function
#-----------------------------------------------------------------------
# cmtsolut parameters: (not valid for sourceparams)
cmt_STF = heavis                         ; 'dirac_0', 'quheavi', 'gauss_0', 'gauss_1' (1st deriv), 'gauss_2' (2nd), 'heavis' 

cmt_lat = 90.0                           ; source latitude [degrees]
cmt_lon = 0.0                            ; source longitude [degrees]
cmt_dp = 10.                             ; source depth [km]

cmt_Mrr = 1.0000e+27                     ; Mrr component
cmt_Mtt = 0.0000e+27                     ; Mtt component
cmt_Mpp = 0.0000e+27                     ; Mpp component
cmt_Mrt = 0.0000e+27                     ; Mrt component
cmt_Mrp = 0.0000e+27                     ; Mrp component
cmt_Mtp = 0.0000e+27                     ; Mtp component

[post_processing]
post_rotate = .true.                     ; rotate receivers?
post_components = 'enz'                  ; receiver components: enz,sph,cyl,xyz,src
post_full_Mij = .true.                   ; sum to full Mij
post_conv_period = 0.                    ; convolve period (0. if not convolved)
post_STF = 'gauss_0'                     ; source time function type for convolution
post_dv = disp                           ; disp or velo seismograms

post_Mrr = N                             ; Mrr
post_Mtt = N                             ; Mtt
post_Mpp = N                             ; Mpp
post_Mrt = N                             ; Mrt
post_Mrp = N                             ; Mrp
post_Mtp = N                             ; Mtp

post_Scolat = N                          ; Source colatitude
post_Slon = N                            ; Source longitude
post_snap = N                            ; plot global snaps?
post_path = N                            ; Directory for post processed data
post_negative = N                        ; seismograms at negative time (0 at max. of stf)

[MISC]
mseed = N                                ; convert the seismograms into MSEED format
mseed_all = N                            ; convert the seismograms into MSEED format

convSTF = Y                              ; after converting the seismograms into MSEED, convolve with STF
halfduration = 5.0                       ; halfduration (do not confuse that with halfduration in the test_section)

filter = Y                               ; if you want to appy a filter (lowpass and highpass as defined below)
fmin = 0.012                             ; minimum frequency
fmax = 0.1                               ; maximum frequency

[testing]
# Parameters required for the TESING directoryi
# for running the tests automatically please refer to test_axisem.py
test = N                                 ; if you want to test AXISEM?
test_folder = ./automated/test_99        ; address of the test folder
plot = Y                                 ; to just plot the test waveforms
save_plots = N                           ; save the plots to a file
plot_format = png                        ; file format of the plots
chans = ['Z', 'N']                       ; required channels
fmin = 0.0005                            ; minimum frequency
fmax = 0.02                              ; maximum frequency
halfduration = 20.                       ; halfduration for the Source Time Function
nstat = 20
